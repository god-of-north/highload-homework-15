
input {
    stdin {
   type => "mysql-slow"
   codec => multiline {
      pattern => "^# User@Host:"
      negate => true
      what => "previous"
    }
    }
}

filter {

  grok {
    match => {"message" => "SELECT SLEEP"}
    add_tag => ["sleep_drop"]
    tag_on_failure => [] 
  }

  if "sleep_drop" in [tags] {
    drop {}
  }
 grok {
  match => [ "message", "(?m)^# User@Host: %{USER:user}\[[^\]]+\] @ (?:(?<clienthost>\S*) )?\[(?:%{IP:clientip})?\]\s*Id: %{NUMBER:id:int}\s+# Query_time: %{NUMBER:query_time:float}\s+Lock_time: %{NUMBER:lock_time:float}\s+Rows_sent: %{NUMBER:rows_sent:int}\s+Rows_examined: %{NUMBER:rows_examined:int}\s*(?:use %{DATA:database};\s*)?SET timestamp=%{NUMBER:timestamp};\s*(?<query>(?<action>\w+)\s+.*)\n# Time:.*$" ]
 }

# not bad
# "^# User@Host: %{USER:user}\[%{USER:current_user}\]%{SPACE}@%{SPACE}\[%{IP:ip}\](.|\r|\n)*# Query_time: %{NUMBER:query_time:float}%{SPACE}Lock_time:%{SPACE}%{NUMBER:lock_time}%{SPACE}Rows_sent:%{SPACE}%{NUMBER:rows_sent:int}%{SPACE}Rows_examined:%{SPACE}%{NUMBER:rows_examined:int}(.|\r|\n)*SET%{SPACE}timestamp=%{NUMBER:timestamp};(.|\r|\n)*%{GREEDYDATA:query}"

  date {
    match => ["timestamp", "UNIX"]
    remove_field => ["timestamp"]
  }
}

output {
    #elasticsearch { host => localhost }
    stdout { codec => rubydebug }
}
