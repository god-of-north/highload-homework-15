
input {
    stdin {
    }

  codec => multiline {
    what => next
    pattern => "^# Time:"
  }
  codec => multiline {
    what => previous
    negate => true
    pattern => "^# User@Host:"
  }
}

filter {
  mutate { replace => { "type" => "mysql-slow" } }


  grok {
    match => [ "message", "^# User@Host: %{USER:mysql_user}(?:\[[^\]]+\])?\s+@\s+%{HOST:mysql_client_host}?\s+\[%{IP:mysql_client_ip}?\]" ]
  }
  grok {
    match => [ "message", "^# Query_time: %{NUMBER:query_duration_s:float}\s+Lock_time: %{NUMBER:lock_wait_s:float} Rows_sent: %{NUMBER:query_sent_rows:int} \s*Rows_examined: %{NUMBER:query_examined_rows:int}"]
  }
  # Capture the time the query happened
  grok {
    match => [ "message", "^SET timestamp=%{NUMBER:timestamp};" ]
  }
  # Capture the tablename
  grok {
    match => {
      "message" => [
        "^FROM %{NOTSPACE:query_table}",
        "^UPDATE %{NOTSPACE:query_table}.*",
        "^INSERT INTO %{NOTSPACE:query_table}.*",
        "^DELETE FROM %{NOTSPACE:query_table}.*"
      ]
    }
  }
  # Extract the time based on the time of the query and
  # not the time the item got logged
  date {
    match => [ "timestamp", "UNIX" ]
  }
}

output {
    #elasticsearch { host => localhost }
    stdout { codec => rubydebug }
}
